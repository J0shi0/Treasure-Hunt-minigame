# Игра "Охота за сокровищами"
Этот код на Python реализует игру "Охота за сокровищами" на сетке 10х10. У игрока есть ограниченное количество попыток найти спрятанное сокровище, которым помогают подсказки на этом пути.

### Особенности:
- *Случайное размещение сокровищ:* Расположение сокровищ выбирается случайным образом для каждой игры.
- *Множество сокровищ:* В игре может быть спрятано несколько сокровищ, что повышает сложность и реиграбельность. (В настоящее время установлено значение "2 сокровища")
- *Система подсказок:* Игроки получают подсказки, указывающие на их близость к сокровищу, которые помогают им в поиске.
- *Счетчик попыток:* Отслеживает количество использованных попыток.
- *Условия выигрыша/проигрыша:* Игра поздравляет игроков с успехом и сообщает им об оставшихся попытках.
### Как играть:
- *Запуск сценария*: Запустите игру с помощью python treasure_hunt.py.
- *Введите координаты*: Следуйте инструкциям, чтобы ввести координаты X и Y (0-9) для вашей догадки.
- *Получите обратную связь*: Игра покажет, близко ли вы находитесь, или предоставит подсказки, которые помогут вам в поиске.
- *Найдите сокровища*: Продолжайте угадывать стратегически, пока не обнаружите все спрятанные сокровища!
### Зависимости:
Эта игра основана на следующих модулях Python:

`random` - Генерирует случайные числа для размещения сокровищ.
`os` (необязательно) - Создает лог-файл для отслеживания предположений игроков.
### Запуск игры:
- Убедитесь, что у вас установлен Python (рекомендуется версия 3).
- Сохраните игровой скрипт как treasure_hunt.py.
- Откройте терминал или командную строку и перейдите в каталог, содержащий скрипт.
- Запустите игру, используя команду: python treasure_hunt.py
дополнительные примечания:
- В коде используются управляющие последовательности цветов ANSI для улучшения вывода на консоль (необязательно).
Не стесняйтесь изменять количество спрятанных сокровищ (в настоящее время оно равно 2), отредактировав функцию multiple_treasures в классе TreasureMap.


### Атрибуты класса:

- `self.x = x`
- `self.y = y`
### Инициализация:

`TreasureMap(x=None, y=None)`

- Создает объект `TreasureMap`.
- При необходимости принимает начальные координаты `x` и `y` для определения местоположения сокровища.
- Если координаты не указаны, то для `x` и `y` устанавливается значение `None` (это означает, что местоположение клада еще не определено).

### Методы:

1. #### `generate_treasure()`:

    - Генерирует случайное местоположение сокровищ в пределах сетки 10х10.
    - Использует `random.randint(0, 9)` для генерации координат `x` и `y` в диапазоне от 0 до 9 (включительно).
    - Возвращает кортеж, содержащий сгенерированные координаты `x` и `y` (например, `(3, 7)`).

2. #### `multiple_treasures(number)`:

    - Создает заданное количество уникальных местоположений сокровищ в сетке 10x10.
    - Принимает в качестве входных данных целое число `numbre`, представляющее желаемое количество сокровищ.
    - Генерирует количество сокровищ, используя метод `generate_treasure()`.
    - Гарантирует, что каждое сокровище имеет уникальное местоположение, сверяясь с существующими сокровищами перед добавлением их в список.
    - Возвращает список (`treasure`), содержащий координаты всех сгенерированных сокровищ.

3. #### `treasure_check(player_x, player_y)`:

   * Определяет, нашел ли игрок спрятанное сокровище.
   * Принимает два целых аргумента, `player_x` и `player_y`, представляющих текущее местоположение игрока.
   * Сравнивает координаты игрока с сохраненным местоположением сокровища (`x` и `y`).
   * Возвращает значение `True`, если координаты игрока совпадают с местоположением сокровища, в противном случае - значение `False`.

4. #### `get_hint(player_x, player_y)`:

   * Дает подсказку игроку, основанную на его близости к спрятанному сокровищу.
   * Принимает два целых аргумента, `player_x` и `player_y`, представляющих текущее местоположение игрока.
   * Проверяет, находится ли местоположение игрока в пределах сетки 3х3 с центром в сокровищнице.
   * Использует сравнение абсолютных значений (`abs()`), чтобы определить, находится ли игрок рядом (по горизонтали, вертикали или диагонали) с сокровищем.
   * Возвращает значение `True`, если игрок находится в пределах зоны подсказок 3x3, в противном случае значение `False`.

### Атрибуты класса:
   * `self.x = x`
   * `self.y = y`
   * `self.trys = 0`
### Инициализация:

`Player()`

- Создает объект `Player`.
- При необходимости принимает начальные координаты `x` и `y` для определения местоположения игрока.
- Если координаты не указаны, то для `x` и `y` устанавливается значение `None` (это означает, что местоположение игрока еще не определено).
- Переменная `trys` отображает количество попыток, которые игрок совершает при введении координат и равняется 0 при инициализации.

### Методы:

1. #### `choose_position():`:

   * Вызывает встроенную функцию `input()` для ввода координат игрока пользователем.
   * Ввод находится в бесконечном цикле.
   * Принимает только целочисленные значения от 0 до 9 для `x` и `y` переменной.
   * Если значения попадают в промежуток от 0 до 9, то метод возвращает эти значения, в противном случае поднимется ошибка `ValueError`.

### Функции:

#### `notice(message, trys=None, hint=None, quantety=None)`:
Предоставляет игроку сообщения о ходе игры.

### Аргументы:
* `message (str)`: тип отображаемого сообщения.
  - "start": Приветственное сообщение, объясняющее правила игры.
  - "found": Поздравительное сообщение с обнаружением сокровища.
  - "win": сообщение о победе с указанием количества попыток и промокода.
  - "lose": Сообщение о том, что у игрока закончились попытки.
  - "founded_treasure": Сообщение, информирующее игрока о том, что он уже нашел сокровище в этом месте.
  - "hint": дает подсказку о местонахождении сокровища.
* `trys (int, необязательно)`: Количество попыток, предпринятых игроком (по умолчанию: `None`). Используется в сообщениях "win" и "hint".
* `hint (bool, необязательно)`: Указывает, следует ли указывать подсказку для сообщения "hint" (по умолчанию: `None`).
*  `quantety (int, необязательно)`: Количество оставшихся сокровищ (по умолчанию: `None`). Используется в сообщении "hint".


### Возвращается:
* `str`: Отформатированное сообщение, основанное на предоставленных аргументах.
* `NotImplementedError`: если указан нераспознанный аргумент сообщения.

#### `game_field(grid=None, check=None, treasure=None, player=None)`:

### Аргументы:
`grid (grid[list[str]], необязательно)`: Существующая сетка игрового поля (по умолчанию: `None`).
`check (bool, необязательно)`: Указывает, следует ли открывать сокровище (по умолчанию: `None`).
`treasure (кортеж[int, int], необязательно)`: Координаты спрятанного сокровища (по умолчанию: `None`).
`player (кортеж[int, инт], необязательно)`: Координаты текущего игрока (по умолчанию: `None`).

### Возвращается:
`grid[list[str]]`: Обновленная сетка игрового поля

Эта функция отвечает за создание и отображение игрового поля для игры "Охота за сокровищами". Она принимает необязательный аргумент `grid`, представляющий существующую сетку игрового поля, и необязательные аргументы `check`, `treasure` и `player`, указывающие, показывать ли сокровище, координаты сокровища и игрока соответственно.

Ниже приведено описание этапов работы функции:

1. Инициализация переменных:

   * `index`: переменная счетчика для отслеживания строк
   * `ANSI_RESET, ANSI_GREEN, ANSI_RED`: коды `ANSI` для сброса цвета текста, зеленого текста и красного текста соответственно

2. Проверьте, нет ли пустой сетки:

   * Если сетка отсутствует или пуста, инициализируйте новую сетку с 10 строками и 10 столбцами, каждая ячейка которых содержит '[0]'.

3. Выполните итерацию по строкам:
   * Для каждой строки в сетке:
     * Если индекс строки совпадает с координатой игрока по оси y и флажок установлен неверно, отметьте позицию игрока красным крестиком, используя коды `ANSI`.
     * Если индекс строки совпадает с координатой y клада и проверка верна, укажите клад зеленой буквой "V", используя коды `ANSI`.
     * Увеличьте счетчик индексов.

4. Верните обновленную сетку:

   * Верните обновленную сетку игрового поля с указанием позиции игрока и/или клада, если это применимо.

